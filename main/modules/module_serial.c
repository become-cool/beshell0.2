#include "utils.h"
#include "module_serial.h"
#include <string.h>
#include "driver/i2s.h"

// #define DMA_CHAN        2

uint8_t _spi_bus_setup = 0 ;
spi_device_handle_t _spi_handle_pool1[8] = {0,0,0,0,0,0,0,0} ;

uint8_t _i2c_bus_setup = 0 ;

static int8_t find_free_spi_handle(spi_device_handle_t ** pool) {
    int8_t h = 0 ;
    for(h=0; h<8; h++) {
        if(_spi_handle_pool1[h]==NULL) {
            *pool = & _spi_handle_pool1 ;
            return h ;
        }
    }
    return -1 ;
}

static spi_device_handle_t _spi_handle(uint8_t idx) {
    if(idx<8) {
        return _spi_handle_pool1[idx] ;
    }
    return NULL ;
}

/**
 * spi bus num 1-3
 * miso
 * mosi
 * clk
 */
static JSValue js_spi_bus_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(4)

    int8_t misopin = -1 ;
    int8_t mosipin = -1 ;
    if(!JS_IsUndefined(argv[1]) && !JS_IsNull(argv[1])) {
        if( JS_ToUint32(ctx, &misopin, argv[1])!=0 ){
            THROW_EXCEPTION("MISO pin invalid.")
        }
    }
    if(!JS_IsUndefined(argv[2]) && !JS_IsNull(argv[2])) {
        if( JS_ToUint32(ctx, &mosipin, argv[2])!=0 ){
            THROW_EXCEPTION("MOSI pin invalid.")
        }
    }

    ARGV_TO_UINT8(0, busnum)
    if(busnum<0 || busnum>3) {
        THROW_EXCEPTION("Bus num must be 1-3")
    }
    ARGV_TO_UINT8(3, clkpin)

    // pf("miso=%d, mosi=%d, clk=%d", misopin, mosipin, clkpin)
    // dn(busnum)

    spi_bus_config_t buscfg = {
        .miso_io_num=misopin,
        .mosi_io_num=mosipin,
        .sclk_io_num=clkpin,
        .quadwp_io_num=-1,
        .quadhd_io_num=-1,
        .max_transfer_sz=20480
    } ;

    esp_err_t ret = spi_bus_initialize(busnum, &buscfg, SPI_DMA_CH2);
    if(ret==0) {
        _spi_bus_setup|= 1<<busnum ;
    }

    return JS_NewInt32(ctx, ret) ;
}

/**
 * spi bus num 0-2
 */
static JSValue js_spi_bus_free(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_TO_UINT8(0, busnum)
    if(busnum<0 || busnum>2) {
        THROW_EXCEPTION("Bus num must be 0-2")
    }
    esp_err_t ret = spi_bus_free(busnum) ;
    if(ret==0) {
        _spi_bus_setup&= ~(1<<busnum) ;
    }

    return JS_NewInt32(ctx, ret) ;
}

/**
 * spi bus num 1-3
 * cspin pin (-1 表示不使用)
 * freq
 * mode
 */
static JSValue js_spi_device_add(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    spi_device_handle_t handle = NULL ;
    uint8_t spi_handle_index ;
    spi_device_handle_t * spipool ;
    int8_t spiidx = find_free_spi_handle(&spipool) ;
    if(spiidx<0) {
        THROW_EXCEPTION("SPI Handle too much")
    }

    CHECK_ARGC(4)
    ARGV_TO_UINT8(0, bus)
    ARGV_TO_UINT8(1, cspin)
    ARGV_TO_UINT32(2, freq)
    ARGV_TO_UINT8(3, mode)
    
    spi_device_interface_config_t devcfg={
        .clock_speed_hz=freq,
        .mode=mode,
        .spics_io_num=cspin,
        .queue_size=7,                          //We want to be able to queue 7 transactions at a time
        .pre_cb=NULL,
    };
    esp_err_t ret=spi_bus_add_device(bus, &devcfg, &spipool[spiidx]);
    return JS_NewInt32(ctx, ret!=0? -1: spiidx) ;
}
static JSValue js_spi_device_remove(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    return JS_UNDEFINED ;
}

/**
 * 
 * bus (1-3)
 * data {string|ArrayBuffer}
 * offset?
 * length?
 */
static JSValue js_spi_send(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(2)
    ARGV_TO_UINT8(0, spiidx)
    spi_device_handle_t handle = _spi_handle(spiidx) ;
    if(handle==NULL) {
        THROW_EXCEPTION("know spi handle")
    }

    int offset = 0 ;
    if(argc>=3) {
        if( JS_ToInt32(ctx, &offset, argv[2])!=0 ) {
            THROW_EXCEPTION("Invalid param type for offset");
        }
    }
    int length = -1 ;
    if(argc>=4) {
        if( JS_ToInt32(ctx, &length, argv[3])!=0 ) {
            THROW_EXCEPTION("Invalid param type for length");
        }
    }

    spi_transaction_t t;
    memset(&t, 0, sizeof(t));

    esp_err_t ret = -1 ;
    if(JS_IsString(argv[1])) {
        t.tx_buffer = JS_ToCStringLen(ctx, &t.length, argv[1]) ;
        if(length>-1 && length<t.length) {
            t.length = length ;
        }
        t.length*= 8 ;
        ret = spi_device_transmit(handle, &t) ;

        JS_FreeCString(ctx, t.tx_buffer) ;
        goto end ;
    }

    t.tx_buffer = JS_GetArrayBuffer(ctx, &t.length, argv[1]) ;
    if(t.tx_buffer) {
        if(length>-1 && length<t.length) {
            t.length = length ;
        }
        t.length*= 8 ;
        ret = spi_device_transmit(handle, &t) ;
        // JS_FreeValue(ctx, argv[1]) ;
    }
    else {
        THROW_EXCEPTION("Invalid data")
    }

end:
    return JS_NewInt32(ctx, ret) ;
}

static JSValue js_spi_recv(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    return JS_UNDEFINED ;
}



const unsigned char dmpmemorydata[1929] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF};

const unsigned char dmpcfgupddata[239] = {
    //  dmp config
    //  BANK    OFFSET  LENGTH  [DATA]
    0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C,
    0x03, 0xAB, 0x03, 0x36, 0x56, 0x76,
    0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2,
    0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1,
    0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x03, 0x89, 0x03, 0x26, 0x46, 0x66,
    0x00, 0x6C, 0x02, 0x20, 0x00,
    0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00,
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D,
    0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D,
    0x00, 0xA3, 0x01, 0x00,
    0x00, 0x00, 0x01, 0x01,

    //0x00,   0x00,   0x00,   0x01,  ?LENGTH=0x00,??

    0x07, 0x86, 0x01, 0xFE,
    0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38,
    0x07, 0x7E, 0x01, 0x30,
    0x07, 0x46, 0x01, 0x9A,
    0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38,
    0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38,
    0x02, 0x16, 0x02, 0x00, 0x00,
    // FIFO rate :0x00=200HZ,0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,

    //dmp updates
    0x01, 0xB2, 0x02, 0xFF, 0xFF,
    0x01, 0x90, 0x04, 0x09, 0x23, 0xA1, 0x35,
    0x01, 0x6A, 0x02, 0x06, 0x00,
    0x01, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
    0x01, 0x62, 0x02, 0x00, 0x00,
    0x00, 0x60, 0x04, 0x00, 0x40, 0x00, 0x00};




static esp_err_t i2c_send(uint8_t bus, uint8_t addr, uint8_t * data, size_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    I2C_BEGIN_WRITE(addr) ;
    i2c_master_write(cmd, data, len, true) ;
    I2C_COMMIT(bus) ;
    return res ;
}
esp_err_t i2c_write(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t * data, size_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    I2C_BEGIN_WRITE(addr) ;
    i2c_master_write_byte(cmd, reg, true) ;
    i2c_master_write(cmd, data, len, true) ;
    I2C_COMMIT(bus) ;
    return res ;
}
esp_err_t i2c_write_byte(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t data) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    return i2c_write(bus, addr, reg, &data, 1) ;
}
esp_err_t i2c_read(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t * data, uint8_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    i2c_send(bus,addr,&reg, 1) ;
    I2C_BEGIN_READ(addr)
    I2C_RECV(data,len)
    I2C_COMMIT(bus)
    return res ;
}

static JSValue js_mpu9250_load(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    // firmware
    unsigned char bank;
    unsigned int datanum = 0;
    unsigned lastbank = 1;
    for (datanum = 0; datanum < 1929; datanum++)
    {
        bank = datanum / 256;
        if (lastbank != bank)
        {
            if(i2c_write_byte(0, 0x68, 0x6d, bank)!=ESP_OK) {
                return JS_FALSE ;
            }
            if(i2c_write_byte(0, 0x68, 0x6e, 0)!=ESP_OK) {
                return JS_FALSE ;
            }
        }

        if(i2c_write_byte(0, 0x68, 0x6f, dmpmemorydata[datanum])!=ESP_OK){
            return JS_FALSE ;
        }
        lastbank = bank;
    };


    // cfgdata
    unsigned char line;
    unsigned char datacounts = 0;
    unsigned char bytes2write;
    unsigned char offset;
    unsigned char writingcounts;
    for (line = 0; line < 37; line++)
    {
        bank = dmpcfgupddata[datacounts];
        datacounts++;
        offset = dmpcfgupddata[datacounts];
        datacounts++;
        bytes2write = dmpcfgupddata[datacounts];

        if(i2c_write_byte(0, 0x68, 0x6d, bank)!=ESP_OK){
            return JS_FALSE ;
        }
        if(i2c_write_byte(0, 0x68, 0x6e, offset)!=ESP_OK){
            return JS_FALSE ;
        }
        for (writingcounts = 0; writingcounts < bytes2write; writingcounts++)
        {
            datacounts++;

            if(i2c_write_byte(0, 0x68, 0x6f, dmpcfgupddata[datacounts])!=ESP_OK){
                return JS_FALSE ;
            }
        }
        datacounts++;
    }

    return JS_TRUE ;
}


/**
 * i2c bus num 0-1
 * sda
 * scl
 * freq
 * timeout
 */
static JSValue js_i2c_bus_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(3)
    ARGV_I2C_BUSNUM(0, busnum)
    ARGV_TO_UINT8(1, sdapin)
    ARGV_TO_UINT8(2, sclpin)

    uint32_t freq = 100000 ;
    if(argc>=4) {
        if(JS_ToUint32(ctx, &freq, argv[3]) ) {
            THROW_EXCEPTION("Invalid param type for argv freq");
        }
    }
    uint32_t timeout = 1000 ;
    if(argc>=5) {
        if(JS_ToUint32(ctx, &timeout, argv[4]) ) {
            THROW_EXCEPTION("Invalid param type for argv timeout");
        }
    }

    // dn4(busnum,sdapin,sclpin,freq)

    // 先 delete driver
    if(I2C_IS_SETUP(busnum)){
        i2c_driver_delete(busnum) ;
        _i2c_bus_setup&= ~(1<<busnum) ;
    }

	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = sdapin,
		.scl_io_num = sclpin,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = freq
	};
	if(i2c_param_config(busnum, &i2c_config)!=ESP_OK) {
        return JS_FALSE ;
    }
	if(i2c_driver_install(busnum, I2C_MODE_MASTER, 0, 0, 0)!=ESP_OK) {
        return JS_FALSE ;
    }
    
    _i2c_bus_setup|= 1<<(busnum) ;

	i2c_set_timeout(busnum, timeout) ;

    int setup_time=0;
    int hold_time=0;
    // i2c_set_stop_timing(busnum, 200, 200) ;
    i2c_get_stop_timing(busnum, &setup_time, &hold_time) ;
    // dn2(setup_time, hold_time)

    int sample_time=0;
    int data_hold_time=0;
    i2c_get_data_timing(busnum, &sample_time, &data_hold_time) ;
    // dn2(sample_time, data_hold_time)

    return JS_TRUE ;
}

static JSValue js_i2c_bus_has_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_I2C_BUSNUM(0, busnum)
    return I2C_IS_SETUP(busnum)? JS_TRUE: JS_FALSE ;
}



/**
 * i2c bus num 0-1
 * addr
 */
static JSValue js_i2c_bus_ping(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(2)
    ARGV_I2C_BUSNUM(0, busnum)
    ARGV_TO_UINT8(1, addr)

	I2C_BEGIN_WRITE(addr)
	I2C_COMMIT(busnum)

    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}

/**
 * i2c bus num 0-1
 * addr
 * data {array}
 */
static JSValue js_i2c_bus_send(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(3)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;

    ARGV_TO_UINT8(1, addr)
    if(!JS_IsArray(ctx, argv[2])) {
        THROW_EXCEPTION("arg must be a array")
    }
    uint32_t len = 0 ;
    if(JS_ToUint32(ctx, &len, JS_GetPropertyStr(ctx, argv[2], "length"))!=0) {
        return JS_FALSE ;
    }
    // printf("length: %d\n", len) ;
    
	I2C_BEGIN_WRITE(addr)

    uint8_t * data = NULL ;
    if(len) {
        data = malloc(len) ;
        if(!data) {
            THROW_EXCEPTION("malloc() failed, out of memory?")
        }
        for(uint32_t i=0;i<len;i++) {
            JSValue val = JS_GetPropertyUint32(ctx, argv[2], i) ;
            uint32_t nval = 0 ;
            JS_ToUint32(ctx, &nval, val) ;
            data[i] = nval ;
            JS_FreeValue(ctx, val) ;
        }
        i2c_master_write(cmd, data, len, true) ;
    }

	I2C_COMMIT(busnum)

    if(data)
        free(data) ;

    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}

/**
 * i2c bus num 0-1
 * dev
 * register
 * int8
 */
static JSValue js_i2c_bus_write8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(4)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;
    ARGV_TO_UINT8(1, dev)
    ARGV_TO_UINT8(2, reg)
    ARGV_TO_UINT8(3, byte)
    
	esp_err_t res = i2c_write_byte(busnum, dev, reg, byte) ;
    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}
/**
 * i2c bus num 0-1
 * dev
 * register
 * int16
 */
static JSValue js_i2c_bus_write16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(4)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;
    ARGV_TO_UINT8(1, dev)
    ARGV_TO_UINT8(2, reg)
    ARGV_TO_UINT16(3, data)
    
	esp_err_t res = i2c_write(busnum, dev, reg, &data, 2) ;
    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}
/**
 * i2c bus num 0-1
 * dev
 * register
 * int32
 */
static JSValue js_i2c_bus_write32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(4)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;
    ARGV_TO_UINT8(1, dev)
    ARGV_TO_UINT8(2, reg)
    ARGV_TO_UINT16(3, data)
    
	esp_err_t res = i2c_write(busnum, dev, reg, &data, 4) ;
    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}

static JSValue _i2c_bus_recv(JSContext *ctx, int argc, JSValueConst *argv, unsigned char * buffer, size_t readlen){

    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum)) {
        THROW_EXCEPTION("i2c bus has not setup") ;
    }

    ARGV_TO_UINT8(1, addr)

	I2C_BEGIN_READ(addr)
    I2C_RECV(buffer,readlen)
	I2C_COMMIT(busnum)

    if(ESP_OK!=res) {
        THROW_EXCEPTION("i2c recv failed") ;
    }

    return JS_TRUE ;
}

/**
 * i2c bus num 0-1
 * addr
 * read bytes num
 */
static JSValue js_i2c_bus_recv(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(3)
    ARGV_TO_UINT8(2, readlen)

    if(readlen<1) {
        return JS_NULL ;
    }
    uint8_t * buffer = malloc(readlen) ;
    if(!buffer) {
        THROW_EXCEPTION("malloc() failed, out of memory?") ;
    }
    
    if(_i2c_bus_recv(ctx,argc,argv,buffer,readlen)==JS_EXCEPTION) {
        return JS_EXCEPTION ;
    }
    
    return JS_NewArrayBuffer(ctx, buffer, readlen, freeArrayBuffer, NULL, false) ;
}


/**
 * i2c bus num 0-1
 * addr
 */
static JSValue js_i2c_bus_recv_byte(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(2)
    unsigned char byte = 0 ;
    if(_i2c_bus_recv(ctx,argc,argv,&byte,1)==JS_EXCEPTION) {
        return JS_EXCEPTION ;
    }
    return JS_NewUint32(ctx,byte) ;
}

/**
 * i2c bus num 0-1
 * addr
 * register/cmd  {uint8}
 * read bytes num
 */
static JSValue js_i2c_bus_read(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(4)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;

    ARGV_TO_UINT8(1, addr)
    ARGV_TO_UINT8(2, reg)
    ARGV_TO_UINT8(3, readlen)

    // JS_DupValue(ctx, data) ;
    if(readlen<1) {
        return JS_NULL ;
    }
    
    uint8_t * buffer = malloc(readlen) ;
    if(!buffer) {
        THROW_EXCEPTION("malloc() failed, out of memory?") ;
    }

    JSValue data = JS_NewArrayBuffer(ctx, buffer, readlen, freeArrayBuffer, NULL, false) ;
    if( i2c_read(busnum, addr, reg, buffer, readlen)!=ESP_OK ) {
        JS_FreeValue(ctx, data) ;
        return JS_NULL ;
    }

    return data ;
}


/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_int8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int8_t, 1)
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_int16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int16_t, 2)
    v = ((v&0xFF00)>>8) | ((v&0xFF)<<8) ;
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_int32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int32_t, 4)
    v = ((v&0xFF000000)>>24) | ((v&0xFF0000)>>8) | ((v&0xFF00)<<8) | ((v&0xFF)<<24) ;
    return JS_NewInt32(ctx,v) ;
}

/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_uint8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint8_t, 1)
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_uint16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint16_t, 2)
    v = ((v&0xFF00)>>8) | ((v&0xFF)<<8) ;
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
static JSValue js_i2c_bus_read_uint32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint32_t, 4)
    v = ((v&0xFF000000)>>24) | ((v&0xFF0000)>>8) | ((v&0xFF00)<<8) | ((v&0xFF)<<24) ;
    return JS_NewInt32(ctx,v) ;
}

/**
 * i2c bus num 0-1
 */
static JSValue js_i2c_bus_free(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_I2C_BUSNUM(0, busnum)
    if(I2C_IS_SETUP(busnum)){
        if( i2c_driver_delete(busnum)!=ESP_OK ){
            return JS_FALSE ;
        }
        _i2c_bus_setup&= ~(1<<busnum) ;
    }
    
    return JS_TRUE ;
}


static uint8_t _i2s_bus_setup = 0 ;

static JSValue js_i2s_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
    CHECK_ARGC(1)

    ARGV_TO_UINT8(0, i2s)
    if(i2s!=0 && i2s!=1){
        THROW_EXCEPTION("arg %s must be 0 or 1", "i2s")
    }

    // int bit = I2S_BITS_PER_SAMPLE_32BIT ;
    // int sample_rate = 8000 ;
    // if(){

    // }
    // ARGV_TO_UINT8(1, sample_rate)


    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX),
        .sample_rate = 8000,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2 | ESP_INTR_FLAG_IRAM,
        .dma_buf_count = 2,
        .dma_buf_len = 512,
        .use_apll = true,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
    };


    i2s_pin_config_t pin_config = {
        .ws_io_num = 33,
        .data_out_num = 4,
        .bck_io_num = 26,
        .data_in_num = -1
    };

    if(argc>1) {

        if(!JS_IsObject(argv[1])) {
            THROW_EXCEPTION("arg %s must be an object", "opts");
        }

        ASSIGN_INT_PROP_DEFAULT(argv[1], "mode", i2s_config.mode, (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX))
        ASSIGN_INT_PROP_DEFAULT(argv[1], "sample_rate", i2s_config.sample_rate, 8000)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "bits_per_sample", i2s_config.bits_per_sample, I2S_BITS_PER_SAMPLE_16BIT)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "channel_format", i2s_config.channel_format, I2S_CHANNEL_FMT_RIGHT_LEFT)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "communication_format", i2s_config.communication_format, I2S_COMM_FORMAT_STAND_I2S)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "intr_alloc_flags", i2s_config.intr_alloc_flags, ESP_INTR_FLAG_LEVEL2 | ESP_INTR_FLAG_IRAM)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "dma_buf_count", i2s_config.dma_buf_count, 2)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "dma_buf_len", i2s_config.dma_buf_len, 256)
        
        ASSIGN_UINT_PROP(argv[1], "lrclk", pin_config.ws_io_num)
        ASSIGN_UINT_PROP(argv[1], "sclk", pin_config.bck_io_num)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "sout", pin_config.data_out_num, -1)
        ASSIGN_INT_PROP_DEFAULT(argv[1], "sin", pin_config.data_in_num, -1)
    }

    if(i2s_driver_install(i2s, &i2s_config, 0, NULL)==ESP_OK){
        _i2s_bus_setup|= 1<<i2s ;
    }
    i2s_set_pin(i2s, &pin_config);

    return JS_UNDEFINED ;
}


bool i2s_has_setup(uint8_t busnum) {
    return (1<<busnum) & _i2s_bus_setup ;
}

static JSValue js_i2s_has_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
    CHECK_ARGC(1)
    ARGV_TO_UINT8(0, busnum)
    if(busnum>1){
        THROW_EXCEPTION("arg %s must be 0 or 1", "i2s")
    }
    return i2s_has_setup(busnum)? JS_TRUE : JS_FALSE;
}

static JSValue js_i2s_unsetup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
    ARGV_TO_UINT8(0, busnum)
    if(busnum>1){
        THROW_EXCEPTION("arg %s must be 0 or 1", "i2s")
    }
    if(i2s_driver_uninstall(busnum)==ESP_OK){
        _i2s_bus_setup &= ~(1<<busnum) ;
        return JS_TRUE ;
    }
    else {
        return JS_FALSE ;
    }
}


void be_module_serial_require(JSContext *ctx) {
    
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue beapi = JS_GetPropertyStr(ctx, global, "beapi") ;

    JSValue spi = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, beapi, "spi", spi);
    JS_SetPropertyStr(ctx, spi, "setup", JS_NewCFunction(ctx, js_spi_bus_setup, "setup", 1));
    JS_SetPropertyStr(ctx, spi, "free", JS_NewCFunction(ctx, js_spi_bus_free, "free", 1));
    JS_SetPropertyStr(ctx, spi, "addDevice", JS_NewCFunction(ctx, js_spi_device_add, "addDevice", 1));
    JS_SetPropertyStr(ctx, spi, "removeDevice", JS_NewCFunction(ctx, js_spi_device_remove, "removeDevice", 1));
    JS_SetPropertyStr(ctx, spi, "send", JS_NewCFunction(ctx, js_spi_send, "send", 1));
    JS_SetPropertyStr(ctx, spi, "recv", JS_NewCFunction(ctx, js_spi_recv, "recv", 1));

    JSValue i2c = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, beapi, "i2c", i2c);
    JS_SetPropertyStr(ctx, i2c, "setup", JS_NewCFunction(ctx, js_i2c_bus_setup, "setup", 1));
    JS_SetPropertyStr(ctx, i2c, "hasSetup", JS_NewCFunction(ctx, js_i2c_bus_has_setup, "hasSetup", 1));
    JS_SetPropertyStr(ctx, i2c, "ping", JS_NewCFunction(ctx, js_i2c_bus_ping, "ping", 1));
    JS_SetPropertyStr(ctx, i2c, "send", JS_NewCFunction(ctx, js_i2c_bus_send, "send", 1));
    JS_SetPropertyStr(ctx, i2c, "write8", JS_NewCFunction(ctx, js_i2c_bus_write8, "write8", 1));
    JS_SetPropertyStr(ctx, i2c, "write16", JS_NewCFunction(ctx, js_i2c_bus_write16, "write16", 1));
    JS_SetPropertyStr(ctx, i2c, "write32", JS_NewCFunction(ctx, js_i2c_bus_write32, "write32", 1));
    JS_SetPropertyStr(ctx, i2c, "recv", JS_NewCFunction(ctx, js_i2c_bus_recv, "recv", 1));
    JS_SetPropertyStr(ctx, i2c, "recvByte", JS_NewCFunction(ctx, js_i2c_bus_recv_byte, "recvByte", 1));
    JS_SetPropertyStr(ctx, i2c, "read", JS_NewCFunction(ctx, js_i2c_bus_read, "read", 1));
    JS_SetPropertyStr(ctx, i2c, "read8", JS_NewCFunction(ctx, js_i2c_bus_read_int8, "read8", 1));
    JS_SetPropertyStr(ctx, i2c, "read16", JS_NewCFunction(ctx, js_i2c_bus_read_int16, "read16", 1));
    JS_SetPropertyStr(ctx, i2c, "read32", JS_NewCFunction(ctx, js_i2c_bus_read_int32, "read32", 1));
    JS_SetPropertyStr(ctx, i2c, "readU8", JS_NewCFunction(ctx, js_i2c_bus_read_uint8, "readU8", 1));
    JS_SetPropertyStr(ctx, i2c, "readU16", JS_NewCFunction(ctx, js_i2c_bus_read_uint16, "readU16", 1));
    JS_SetPropertyStr(ctx, i2c, "readU32", JS_NewCFunction(ctx, js_i2c_bus_read_uint32, "readU32", 1));
    JS_SetPropertyStr(ctx, i2c, "free", JS_NewCFunction(ctx, js_i2c_bus_free, "free", 1));

    // JS_SetPropertyStr(ctx, i2c, "mpu9250load", JS_NewCFunction(ctx, js_mpu9250_load, "mpu9250load", 1));

    JSValue i2s = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, beapi, "i2s", i2s);
    JS_SetPropertyStr(ctx, i2s, "setup", JS_NewCFunction(ctx, js_i2s_setup, "setup", 1));
    JS_SetPropertyStr(ctx, i2s, "unsetup", JS_NewCFunction(ctx, js_i2s_unsetup, "unsetup", 1));
    JS_SetPropertyStr(ctx, i2s, "hasSetup", JS_NewCFunction(ctx, js_i2s_has_setup, "hasSetup", 1));


    JS_FreeValue(ctx, global);
    JS_FreeValue(ctx, beapi);
}

void be_module_serial_reset(JSContext *ctx) {
    // 回收 SPI 资源
    for(uint8_t h=0; h<8; h++) {
        if(_spi_handle_pool1[h]!=NULL) {
            spi_bus_remove_device(_spi_handle_pool1[h]) ;
            _spi_handle_pool1[h] = NULL ;
        }
    }
    FREE_BUS_SPI(1)
    FREE_BUS_SPI(2)
    FREE_BUS_SPI(3)
    _spi_bus_setup = 0 ;

    FREE_BUS_I2C(0)
    FREE_BUS_I2C(1)
    _i2c_bus_setup = 0 ;

    FREE_BUS_I2S(0)
    FREE_BUS_I2S(1)
    _i2s_bus_setup = 0 ;
}