#include "utils.h"
#include "module_serial.h"
#include "driver/spi_master.h"
#include "driver/i2c.h"
#include <string.h>

#define DMA_CHAN        2

uint8_t _spi_bus_setup = 0 ;
spi_device_handle_t _spi_handle_pool1[8] = {0,0,0,0,0,0,0,0} ;

uint8_t _i2c_bus_setup = 0 ;


int8_t find_free_spi_handle(spi_device_handle_t ** pool) {
    int8_t h = 0 ;
    for(h=0; h<8; h++) {
        if(_spi_handle_pool1[h]==NULL) {
            *pool = & _spi_handle_pool1 ;
            return h ;
        }
    }
    return -1 ;
}

spi_device_handle_t _spi_handle(uint8_t idx) {
    if(idx<8) {
        return _spi_handle_pool1[idx] ;
    }
    return NULL ;
}

/**
 * spi bus num 0-2
 * clk
 * miso
 * mosi
 */
JSValue js_spi_bus_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(4)

    ARGV_TO_UINT8(0, busnum)
    if(busnum<0 || busnum>2) {
        THROW_EXCEPTION("Bus num must be 0-2")
    }
    ARGV_TO_UINT8(1, clkpin)

    int8_t mosipin = -1 ;
    int8_t misopin = -1 ;
    if(!JS_IsUndefined(argv[2])) {
        if( JS_ToUint32(ctx, &mosipin, argv[2])!=0 ){
            THROW_EXCEPTION("MOSI pin invalid.")
        }
    }
    if(!JS_IsUndefined(argv[3])) {
        if( JS_ToUint32(ctx, &misopin, argv[3])!=0 ){
            THROW_EXCEPTION("MISO pin invalid.")
        }
    }

    // pf("mosi=%d, miso=%d, clk=%d", mosipin, misopin, clkpin)

    spi_bus_config_t buscfg = {
        .miso_io_num=misopin,
        .mosi_io_num=mosipin,
        .sclk_io_num=clkpin,
        .quadwp_io_num=-1,
        .quadhd_io_num=-1,
        .max_transfer_sz=20480
    } ;

    esp_err_t ret = spi_bus_initialize(busnum, &buscfg, DMA_CHAN);
    if(ret==0) {
        _spi_bus_setup|= 1<<busnum ;
    }

    return JS_NewInt32(ctx, ret) ;
}

/**
 * spi bus num 0-2
 */
JSValue js_spi_bus_free(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_TO_UINT8(0, busnum)
    if(busnum<0 || busnum>2) {
        THROW_EXCEPTION("Bus num must be 0-2")
    }
    esp_err_t ret = spi_bus_free(busnum) ;
    if(ret==0) {
        _spi_bus_setup&= ~(1<<busnum) ;
    }

    return JS_NewInt32(ctx, ret) ;
}

/**
 * spi bus num 1-3
 * cspin pin (-1 表示不使用)
 * freq
 * mode
 */
JSValue js_spi_device_add(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    spi_device_handle_t handle = NULL ;
    uint8_t spi_handle_index ;
    spi_device_handle_t * spipool ;
    int8_t spiidx = find_free_spi_handle(&spipool) ;
    if(spiidx<0) {
        THROW_EXCEPTION("SPI Handle too much")
    }

    CHECK_ARGC(4)
    ARGV_TO_UINT8(0, bus)
    ARGV_TO_UINT8(1, cspin)
    ARGV_TO_UINT32(2, freq)
    ARGV_TO_UINT8(3, mode)
    
    spi_device_interface_config_t devcfg={
        .clock_speed_hz=freq,
        .mode=mode,
        .spics_io_num=cspin,
        .queue_size=7,                          //We want to be able to queue 7 transactions at a time
        .pre_cb=NULL,
    };
    esp_err_t ret=spi_bus_add_device(bus, &devcfg, &spipool[spiidx]);
    return JS_NewInt32(ctx, ret!=0? -1: spiidx) ;
}
JSValue js_spi_device_remove(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    return JS_UNDEFINED ;
}

/**
 * 
 * bus (1-3)
 * data {string|ArrayBuffer}
 * offset?
 * length?
 */
JSValue js_spi_send(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(2)
    ARGV_TO_UINT8(0, spiidx)
    spi_device_handle_t handle = _spi_handle(spiidx) ;
    if(handle==NULL) {
        THROW_EXCEPTION("know spi handle")
    }

    int offset = 0 ;
    if(argc>=3) {
        if( JS_ToInt32(ctx, &offset, argv[2])!=0 ) {
            THROW_EXCEPTION("Invalid param type for offset");
        }
    }
    int length = -1 ;
    if(argc>=4) {
        if( JS_ToInt32(ctx, &length, argv[3])!=0 ) {
            THROW_EXCEPTION("Invalid param type for length");
        }
    }

    spi_transaction_t t;
    memset(&t, 0, sizeof(t));

    esp_err_t ret = -1 ;
    if(JS_IsString(argv[1])) {
        t.tx_buffer = JS_ToCStringLen(ctx, &t.length, argv[1]) ;
        if(length>-1 && length<t.length) {
            t.length = length ;
        }
        t.length*= 8 ;
        ret = spi_device_transmit(handle, &t) ;

        JS_FreeCString(ctx, t.tx_buffer) ;
        goto end ;
    }

    t.tx_buffer = JS_GetArrayBuffer(ctx, &t.length, argv[1]) ;
    if(t.tx_buffer) {
        if(length>-1 && length<t.length) {
            t.length = length ;
        }
        t.length*= 8 ;
        ret = spi_device_transmit(handle, &t) ;
        // JS_FreeValue(ctx, argv[1]) ;
    }
    else {
        THROW_EXCEPTION("Invalid data")
    }

end:
    return JS_NewInt32(ctx, ret) ;
}

JSValue js_spi_recv(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    return JS_UNDEFINED ;
}



const unsigned char dmpmemorydata[1929] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF};

const unsigned char dmpcfgupddata[239] = {
    //  dmp config
    //  BANK    OFFSET  LENGTH  [DATA]
    0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C,
    0x03, 0xAB, 0x03, 0x36, 0x56, 0x76,
    0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2,
    0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1,
    0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x03, 0x89, 0x03, 0x26, 0x46, 0x66,
    0x00, 0x6C, 0x02, 0x20, 0x00,
    0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00,
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D,
    0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D,
    0x00, 0xA3, 0x01, 0x00,
    0x00, 0x00, 0x01, 0x01,

    //0x00,   0x00,   0x00,   0x01,  ?LENGTH=0x00,??

    0x07, 0x86, 0x01, 0xFE,
    0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38,
    0x07, 0x7E, 0x01, 0x30,
    0x07, 0x46, 0x01, 0x9A,
    0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38,
    0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38,
    0x02, 0x16, 0x02, 0x00, 0x00,
    // FIFO rate :0x00=200HZ,0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,

    //dmp updates
    0x01, 0xB2, 0x02, 0xFF, 0xFF,
    0x01, 0x90, 0x04, 0x09, 0x23, 0xA1, 0x35,
    0x01, 0x6A, 0x02, 0x06, 0x00,
    0x01, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
    0x01, 0x62, 0x02, 0x00, 0x00,
    0x00, 0x60, 0x04, 0x00, 0x40, 0x00, 0x00};


#define I2C_IS_SETUP(busnum) (_i2c_bus_setup & (1<<(busnum)))

#define ARGV_I2C_BUSNUM(i, var)                     \
    ARGV_TO_UINT8(i, var)                           \
    if(var<0 || var>1) {                            \
        THROW_EXCEPTION("Bus num must be 0-1")      \
    }

#define I2C_BEGIN(addr, act)                                        \
	i2c_cmd_handle_t cmd = i2c_cmd_link_create();                   \
	i2c_master_start(cmd);                                          \
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_##act, true);
    
#define I2C_BEGIN_READ(addr)    I2C_BEGIN(addr, READ)
#define I2C_BEGIN_WRITE(addr)   I2C_BEGIN(addr, WRITE)

#define I2C_RECV(buffer, len)                                       \
    if(len>1) {                                                     \
	    i2c_master_read(cmd, buffer, len-1, I2C_MASTER_ACK);        \
	    i2c_master_read(cmd, (buffer)+len-1, 1, I2C_MASTER_NACK);   \
    }                                                               \
    else {                                                          \
	    i2c_master_read(cmd, buffer, 1, I2C_MASTER_NACK);           \
    }

#define I2C_COMMIT(bus)                                                     \
	i2c_master_stop(cmd);                                                   \
	esp_err_t res=i2c_master_cmd_begin(bus, cmd, 10/portTICK_PERIOD_MS) ;   \
	i2c_cmd_link_delete(cmd);



esp_err_t i2c_send(uint8_t bus, uint8_t addr, uint8_t * data, size_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    I2C_BEGIN_WRITE(addr) ;
    i2c_master_write(cmd, data, len, true) ;
    I2C_COMMIT(bus) ;
    return res ;
}
esp_err_t i2c_write(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t * data, size_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    I2C_BEGIN_WRITE(addr) ;
    i2c_master_write_byte(cmd, reg, true) ;
    i2c_master_write(cmd, data, len, true) ;
    I2C_COMMIT(bus) ;
    return res ;
}
esp_err_t i2c_write_byte(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t data) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    return i2c_write(bus, addr, reg, &data, 1) ;
}
esp_err_t i2c_read(uint8_t bus, uint8_t addr, uint8_t reg, uint8_t * data, uint8_t len) {
    if(!I2C_IS_SETUP(bus))
        return ESP_ERR_INVALID_STATE ;
    i2c_send(bus,addr,&reg, 1) ;
    I2C_BEGIN_READ(addr)
    I2C_RECV(data,len)
    I2C_COMMIT(bus)
    return res ;
}

JSValue js_mpu9250_load(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    // firmware
    unsigned char bank;
    unsigned int datanum = 0;
    unsigned lastbank = 1;
    for (datanum = 0; datanum < 1929; datanum++)
    {
        bank = datanum / 256;
        if (lastbank != bank)
        {
            if(i2c_write_byte(0, 0x68, 0x6d, bank)!=ESP_OK) {
                return JS_FALSE ;
            }
            if(i2c_write_byte(0, 0x68, 0x6e, 0)!=ESP_OK) {
                return JS_FALSE ;
            }
        }

        if(i2c_write_byte(0, 0x68, 0x6f, dmpmemorydata[datanum])!=ESP_OK){
            return JS_FALSE ;
        }
        lastbank = bank;
    };


    // cfgdata
    unsigned char line;
    unsigned char datacounts = 0;
    unsigned char bytes2write;
    unsigned char offset;
    unsigned char writingcounts;
    for (line = 0; line < 37; line++)
    {
        bank = dmpcfgupddata[datacounts];
        datacounts++;
        offset = dmpcfgupddata[datacounts];
        datacounts++;
        bytes2write = dmpcfgupddata[datacounts];

        if(i2c_write_byte(0, 0x68, 0x6d, bank)!=ESP_OK){
            return JS_FALSE ;
        }
        if(i2c_write_byte(0, 0x68, 0x6e, offset)!=ESP_OK){
            return JS_FALSE ;
        }
        for (writingcounts = 0; writingcounts < bytes2write; writingcounts++)
        {
            datacounts++;

            if(i2c_write_byte(0, 0x68, 0x6f, dmpcfgupddata[datacounts])!=ESP_OK){
                return JS_FALSE ;
            }
        }
        datacounts++;
    }

    return JS_TRUE ;
}


/**
 * i2c bus num 0-1
 * sda
 * scl
 * freq
 * timeout
 */
JSValue js_i2c_bus_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(3)
    ARGV_I2C_BUSNUM(0, busnum)
    ARGV_TO_UINT8(1, sdapin)
    ARGV_TO_UINT8(2, sclpin)

    uint32_t freq = 400000 ;
    if(argc>=4) {
        if(JS_ToUint32(ctx, &freq, argv[3]) ) {
            THROW_EXCEPTION("Invalid param type for argv freq");
        }
    }
    uint32_t timeout = 2000 ;
    if(argc>=5) {
        if(JS_ToUint32(ctx, &timeout, argv[4]) ) {
            THROW_EXCEPTION("Invalid param type for argv timeout");
        }
    }

    // 先 delete driver
    if(I2C_IS_SETUP(busnum)){
        i2c_driver_delete(busnum) ;
        _i2c_bus_setup&= ~(1<<busnum) ;
    }

	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = sdapin,
		.scl_io_num = sclpin,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = freq
	};
	if(i2c_param_config(busnum, &i2c_config)!=ESP_OK) {
        return JS_FALSE ;
    }
	if(i2c_driver_install(busnum, I2C_MODE_MASTER, 0, 0, 0)!=ESP_OK) {
        return JS_FALSE ;
    }
    
    _i2c_bus_setup|= 1<<(busnum) ;

	i2c_set_timeout(busnum, timeout) ;

    return JS_TRUE ;
}

JSValue js_i2c_bus_has_setup(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_I2C_BUSNUM(0, busnum)
    return I2C_IS_SETUP(busnum)? JS_TRUE: JS_FALSE ;
}



/**
 * i2c bus num 0-1
 * addr
 */
JSValue js_i2c_bus_ping(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(2)
    ARGV_I2C_BUSNUM(0, busnum)
    ARGV_TO_UINT8(1, addr)

	I2C_BEGIN_WRITE(addr)
	I2C_COMMIT(busnum)

    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}

/**
 * i2c bus num 0-1
 * addr
 * data {array}
 */
JSValue js_i2c_bus_send(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(3)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;

    ARGV_TO_UINT8(1, addr)
    if(!JS_IsArray(ctx, argv[2])) {
        THROW_EXCEPTION("arg must be a array")
    }
    uint32_t len = 0 ;
    if(JS_ToUint32(ctx, &len, JS_GetPropertyStr(ctx, argv[2], "length"))!=0) {
        return JS_FALSE ;
    }
    // printf("length: %d\n", len) ;
    
	I2C_BEGIN_WRITE(addr)

    uint8_t * data = NULL ;
    if(len) {
        data = malloc(len) ;
        if(!data) {
            THROW_EXCEPTION("malloc() failed, out of memory?")
        }
        for(uint32_t i=0;i<len;i++) {
            JSValue val = JS_GetPropertyUint32(ctx, argv[2], i) ;
            uint32_t nval = 0 ;
            JS_ToUint32(ctx, &nval, val) ;
            data[i] = nval ;
            JS_FreeValue(ctx, val) ;
        }
        i2c_master_write(cmd, data, len, true) ;
    }

	I2C_COMMIT(busnum)

    if(data)
        free(data) ;

    return res==ESP_OK? JS_TRUE: JS_FALSE ;
}

/**
 * i2c bus num 0-1
 * addr
 * read bytes num
 */
JSValue js_i2c_bus_recv(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){

    CHECK_ARGC(3)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;

    ARGV_TO_UINT8(1, addr)
    ARGV_TO_UINT8(2, readlen)

    // JS_DupValue(ctx, data) ;
    if(readlen<1) {
        return JS_NULL ;
    }

    uint8_t * buffer = malloc(readlen) ;
    if(!buffer) {
        THROW_EXCEPTION("malloc() failed, out of memory?") ;
    }
    
    JSValue data = JS_NewArrayBuffer(ctx, buffer, readlen, freeArrayBuffer, NULL, false) ;

	I2C_BEGIN_READ(addr)
    I2C_RECV(buffer,readlen)
	I2C_COMMIT(busnum)

    if(ESP_OK!=res) {
        return JS_NULL ;
    }
    return data ;
}

/**
 * i2c bus num 0-1
 * addr
 * register/cmd  {uint8}
 * read bytes num
 */
JSValue js_i2c_bus_read(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(4)
    ARGV_I2C_BUSNUM(0, busnum)
    if(!I2C_IS_SETUP(busnum))
        return JS_FALSE ;

    ARGV_TO_UINT8(1, addr)
    ARGV_TO_UINT8(2, reg)
    ARGV_TO_UINT8(3, readlen)

    // JS_DupValue(ctx, data) ;
    if(readlen<1) {
        return JS_NULL ;
    }
    
    uint8_t * buffer = malloc(readlen) ;
    if(!buffer) {
        THROW_EXCEPTION("malloc() failed, out of memory?") ;
    }

    JSValue data = JS_NewArrayBuffer(ctx, buffer, readlen, freeArrayBuffer, NULL, false) ;
    if( i2c_read(busnum, addr, reg, buffer, readlen)!=ESP_OK ) {
        JS_FreeValue(ctx, data) ;
        return JS_NULL ;
    }

    return data ;
}

#define I2C_READ_INT(var, type, size)                                   \
    CHECK_ARGC(3)                                                       \
    ARGV_I2C_BUSNUM(0, busnum)                                          \
    if(!I2C_IS_SETUP(busnum))                                           \
        return JS_NULL ;                                                \
    ARGV_TO_UINT8(1, addr)                                              \
    ARGV_TO_UINT8(2, reg)                                               \
    type var = 0 ;                                                      \
    if( i2c_read(busnum, addr, reg, (uint8_t*)&var, size)!=ESP_OK ) {   \
        return JS_NULL ;                                                \
    }


/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_int8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int8_t, 1)
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_int16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int16_t, 2)
    v = ((v&0xFF00)>>8) | ((v&0xFF)<<8) ;
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_int32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, int32_t, 4)
    v = ((v&0xFF000000)>>24) | ((v&0xFF0000)>>8) | ((v&0xFF00)<<8) | ((v&0xFF)<<24) ;
    return JS_NewInt32(ctx,v) ;
}

/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_uint8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint8_t, 1)
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_uint16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint16_t, 2)
    v = ((v&0xFF00)>>8) | ((v&0xFF)<<8) ;
    return JS_NewInt32(ctx,v) ;
}
/**
 * i2c bus num 0-1
 * addr
 * register/cmd
 */
JSValue js_i2c_bus_read_uint32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    I2C_READ_INT(v, uint32_t, 4)
    v = ((v&0xFF000000)>>24) | ((v&0xFF0000)>>8) | ((v&0xFF00)<<8) | ((v&0xFF)<<24) ;
    return JS_NewInt32(ctx,v) ;
}

/**
 * i2c bus num 0-1
 */
JSValue js_i2c_bus_free(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv){
    CHECK_ARGC(1)
    ARGV_I2C_BUSNUM(0, busnum)
    if(I2C_IS_SETUP(busnum)){
        if( i2c_driver_delete(busnum)!=ESP_OK ){
            return JS_FALSE ;
        }
        _i2c_bus_setup&= ~(1<<busnum) ;
    }
    
    return JS_TRUE ;
}

void require_module_serial(JSContext *ctx) {
    
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue beapi = JS_GetPropertyStr(ctx, global, "beapi") ;

    JSValue spi = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, beapi, "spi", spi);
    JS_SetPropertyStr(ctx, spi, "setup", JS_NewCFunction(ctx, js_spi_bus_setup, "setup", 1));
    JS_SetPropertyStr(ctx, spi, "free", JS_NewCFunction(ctx, js_spi_bus_free, "free", 1));
    JS_SetPropertyStr(ctx, spi, "addDevice", JS_NewCFunction(ctx, js_spi_device_add, "addDevice", 1));
    JS_SetPropertyStr(ctx, spi, "removeDevice", JS_NewCFunction(ctx, js_spi_device_remove, "removeDevice", 1));
    JS_SetPropertyStr(ctx, spi, "send", JS_NewCFunction(ctx, js_spi_send, "send", 1));
    JS_SetPropertyStr(ctx, spi, "recv", JS_NewCFunction(ctx, js_spi_recv, "recv", 1));

    JSValue i2c = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, beapi, "i2c", i2c);
    JS_SetPropertyStr(ctx, i2c, "setup", JS_NewCFunction(ctx, js_i2c_bus_setup, "setup", 1));
    JS_SetPropertyStr(ctx, i2c, "hasSetup", JS_NewCFunction(ctx, js_i2c_bus_has_setup, "hasSetup", 1));
    JS_SetPropertyStr(ctx, i2c, "ping", JS_NewCFunction(ctx, js_i2c_bus_ping, "ping", 1));
    JS_SetPropertyStr(ctx, i2c, "send", JS_NewCFunction(ctx, js_i2c_bus_send, "send", 1));
    JS_SetPropertyStr(ctx, i2c, "recv", JS_NewCFunction(ctx, js_i2c_bus_recv, "recv", 1));
    JS_SetPropertyStr(ctx, i2c, "read", JS_NewCFunction(ctx, js_i2c_bus_read, "read", 1));
    JS_SetPropertyStr(ctx, i2c, "readInt8", JS_NewCFunction(ctx, js_i2c_bus_read_int8, "readInt8", 1));
    JS_SetPropertyStr(ctx, i2c, "readInt16", JS_NewCFunction(ctx, js_i2c_bus_read_int16, "readInt16", 1));
    JS_SetPropertyStr(ctx, i2c, "readInt32", JS_NewCFunction(ctx, js_i2c_bus_read_int32, "readInt32", 1));
    JS_SetPropertyStr(ctx, i2c, "readUInt8", JS_NewCFunction(ctx, js_i2c_bus_read_uint8, "readUInt8", 1));
    JS_SetPropertyStr(ctx, i2c, "readUInt16", JS_NewCFunction(ctx, js_i2c_bus_read_uint16, "readUInt16", 1));
    JS_SetPropertyStr(ctx, i2c, "readUInt32", JS_NewCFunction(ctx, js_i2c_bus_read_uint32, "readUInt32", 1));
    JS_SetPropertyStr(ctx, i2c, "free", JS_NewCFunction(ctx, js_i2c_bus_free, "free", 1));

    JS_SetPropertyStr(ctx, i2c, "mpu9250load", JS_NewCFunction(ctx, js_mpu9250_load, "mpu9250load", 1));

    JS_FreeValue(ctx, global);
    JS_FreeValue(ctx, beapi);
}

#define FREE_BUS_SPI(busnum)    if(_spi_bus_setup&(1<<(busnum))){ spi_bus_free(busnum); }
#define FREE_BUS_I2C(busnum)    if(_i2c_bus_setup&(1<<(busnum))){ i2c_driver_delete(busnum); }
void serial_on_before_reset(JSContext *ctx) {
    // 回收 SPI 资源
    for(uint8_t h=0; h<8; h++) {
        if(_spi_handle_pool1[h]!=NULL) {
            spi_bus_remove_device(_spi_handle_pool1[h]) ;
            _spi_handle_pool1[h] = NULL ;
        }
    }
    FREE_BUS_SPI(1)
    FREE_BUS_SPI(2)
    FREE_BUS_SPI(3)
    _spi_bus_setup = 0 ;

    FREE_BUS_I2C(0) ;
    FREE_BUS_I2C(1) ;
    _i2c_bus_setup = 0 ;
}