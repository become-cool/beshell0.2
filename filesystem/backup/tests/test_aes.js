function hexprint(name, b) {
	var o = name + ':';
	for(var i=0;i<b.length;++i) o += ' ' + ('0' + b[i].toString(16)).slice(-2);
	log(o);
}
var alloc8 = Uint8Array.allocPlain;

var aes = require('aes');

// Quickie test of known data related to z-wave security
// YMMV, but it works for me... (dashxdr 20180614)

var KE = alloc8([0x85,0x22,0x71,0x7d,0x3a,0xd1,0xfb,0xfe,0xaf,0xa1,0xce,0xaa,0xfd,0xf5,0x65,0x65]);
var iv = alloc8([0xff,0xf8,0x80,0x8e,0x1c,0xa0,0x5e,0x2e,0x30,0x24,0xf0,0x61,0x84,0x6b,0xe5,0xee]);
// our data blocks must be multiple of 16 bytes
var encrypted = alloc8([
			0x00,0x98,0x06,0x80,0xd9,0x68,0x80,0xcc,0x0b,0x85,0x50,0xb3,0x5d,0xc1,0x08,0x04,
			0x5f,0xe1,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00]);
var temp = alloc8(encrypted.length); // all 0's
var want = alloc8([0xe0,0x93,0xc9,0xb0,0x29,0x3e,0xf3,0x74,0x3f,0x17,0x37,0x52,0x5b,0xb8,0xe9,0x0a,0x00,0x33,0xb9]);

hexprint('KE       ', KE);
hexprint('iv       ', iv);
hexprint('plain    ', encrypted);
aes.fast_aes_128_cbc_encrypt(KE, iv, temp, encrypted.length);
hexprint('raw      ', temp);
for(var i=0;i<temp.length;++i) temp[i] ^= encrypted[i];
hexprint('encrypted', temp);
hexprint('want     ', want);
